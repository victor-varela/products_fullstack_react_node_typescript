1.Backend (Node + Express)
Define las rutas REST (/api/users, /api/tasks, etc.).
Cada ruta maneja una acci√≥n (leer, crear, actualizar o borrar datos).
Se conecta a PostgreSQL mediante un ORM (Sequelize, Prisma, etc.).

// üß© ¬øPor qu√© usamos Express?

// ‚öôÔ∏è Express es un framework para Node.js que nos facilita crear un servidor HTTP.
// Sirve como el "motor de comunicaci√≥n" üö¶ entre el frontend (React) y la base de datos (PostgreSQL).

// üß† Node.js por s√≠ solo provee el entorno donde corre el c√≥digo,
// pero Express agrega una capa m√°s amigable para:
//  1Ô∏è‚É£ Definir rutas REST (GET, POST, PUT, DELETE).
//  2Ô∏è‚É£ Manejar peticiones y respuestas f√°cilmente.
//  3Ô∏è‚É£ Conectar la l√≥gica del servidor con la base de datos.
//  4Ô∏è‚É£ Organizar el c√≥digo en m√≥dulos claros y mantenibles.

// üì¶ Sin Express, podr√≠amos hacer lo mismo usando el m√≥dulo nativo 'http' de Node.js,
// pero ser√≠a mucho m√°s manual. Ejemplo:

/*
import http from 'http'

const server = http.createServer((req, res) => {
  if (req.url === '/' && req.method === 'GET') {
    res.writeHead(200, { 'Content-Type': 'application/json' })
    res.end(JSON.stringify({ message: 'Hola desde Node puro üëã' }))
  } else {
    res.writeHead(404, { 'Content-Type': 'application/json' })
    res.end(JSON.stringify({ error: 'Ruta no encontrada' }))
  }
})

server.listen(4000, () => {
  console.log('Servidor corriendo en http://localhost:4000')
})
*/

// üòÆ Como ves, sin Express tenemos que manejar manualmente:
//   - Las cabeceras de respuesta (headers).
//   - Los c√≥digos de estado HTTP.
//   - El enrutamiento (qu√© hacer seg√∫n la URL y el m√©todo).

// üöÄ En cambio, con Express basta con escribir:
//
/*
import express from 'express'
const server = express()

server.get('/', (req, res) => {
  res.json({ message: 'Hola desde Express üëã' })
})

server.listen(4000, () => console.log('Servidor Express en http://localhost:4000'))
*/
// Mucho m√°s limpio, legible y f√°cil de escalar. üòé


2.Base de datos (PostgreSQL)
Almacena los datos reales (usuarios, productos, etc.).
El ORM traduce tus objetos JS a consultas SQL para leer o escribir aqu√≠.

3.Frontend (React)
Consume esas rutas con fetch o axios.
Muestra los datos al usuario y env√≠a cambios (por ejemplo, al enviar un formulario).

// ‚öôÔ∏è CONFIGURACI√ìN INICIAL DEL PROYECTO REST API CON TYPESCRIPT Y NODE
// --------------------------------------------------------------------

// 1Ô∏è‚É£ CREACI√ìN DEL PROYECTO BASE
// - Acci√≥n: Crear la carpeta `rest_api_ts_server` y ejecutar `npm init`.
// - Por qu√©: Inicializa un nuevo proyecto Node, generando `package.json`
//   donde se registran dependencias y scripts.
// - Luego: Instalar Express ‚Üí `npm install express` para manejar rutas y peticiones HTTP.
//   (Es el equivalente al ‚ÄúBig Bang‚Äù de Node, como `npm create vite@latest` lo es para React).

// --------------------------------------------------------------------

// 2Ô∏è‚É£ ARCHIVOS PRINCIPALES
// - Acci√≥n: Crear `index.ts` (punto de entrada) y `server.ts` (configuraci√≥n del servidor).
// - Por qu√©: Separar el inicio de la app de su configuraci√≥n hace el proyecto
//   m√°s modular, escalable y f√°cil de mantener.

// --------------------------------------------------------------------

// 3Ô∏è‚É£ SOPORTE PARA TYPESCRIPT
// - Acci√≥n: Instalar dependencias de desarrollo:
//     npm i -D typescript ts-node
// - Por qu√©: Node solo entiende JavaScript; TypeScript necesita un traductor (`tsc`)
//   y un ejecutor (`ts-node`) para poder correr el c√≥digo .ts.
// - Extra: Crear un archivo `tsconfig.json` vac√≠o para que Node reconozca archivos .ts. Luego se completara la configuraci√≥n de ese archivo.
// - Ejecuci√≥n manual del servidor:
//     npx ts-node src/index.ts

// --------------------------------------------------------------------

// 4Ô∏è‚É£ AUTOMATIZAR EL REINICIO DEL SERVIDOR
// - Acci√≥n: Instalar `nodemon` y agregar un script en package.json:
//     "scripts": { "dev": "nodemon --exec ts-node src/index.ts" }
// - Por qu√©: Evita tener que reiniciar el servidor manualmente tras cada cambio.
// - Resultado: Correr `npm run dev` mantiene el servidor activo y actualizando en tiempo real.

// --------------------------------------------------------------------

// 5Ô∏è‚É£ COMPILACI√ìN TYPESCRIPT ‚Üí JAVASCRIPT
// - Acci√≥n: Ejecutar `npx tsc src/index.ts`.
// - Por qu√©: Compila archivos .ts a .js para que Node pueda ejecutarlos.
// - Nota: Eliminar los .js generados en /src para no mezclar archivos de desarrollo
//   con los de producci√≥n (el c√≥digo compilado ir√° a /dist). 

// --------------------------------------------------------------------

// 6Ô∏è‚É£ CONFIGURACI√ìN DEL COMPILADOR (tsconfig.json)
// - Acci√≥n: Configurar reglas para la compilaci√≥n:
//     {
//       "compilerOptions": {
//         "outDir": "./dist",        // Carpeta para c√≥digo compilado
//         "rootDir": "./src",        // Carpeta de c√≥digo fuente
//         "lib": ["ESNext"],         // Funcionalidades modernas de JS - ESNext = EmmaScript Next
                                                                          el mas reciente
//         "strict": false,           // Menos restricciones en tipado
//         "sourceMap": true,         // Permite depurar .ts desde .js
//         "esModuleInterop": true,   // Soporte para imports comunes
//         "declaration": true        // Genera archivos .d.ts (tipos)
//       },
//       "include": ["src/**/*.ts"]
//     }
// - Por qu√©:
//   - `/src` ‚Üí c√≥digo fuente en desarrollo.
//   - `/dist` ‚Üí c√≥digo compilado para producci√≥n.
//   - Facilita depuraci√≥n (sourceMap), compatibilidad (esModuleInterop) y organizaci√≥n general.
//   - Ejecutar npx tsc y ahi va a crear la carpeta dist.
//   - OJO A medida que se va construyendo el proyecto se van agregando configuraciones OJOc

// --------------------------------------------------------------------

// üí° En resumen:
//   npm init  ‚Üí Crea el universo del proyecto Node.
//   Express   ‚Üí Le da forma al backend (maneja rutas y peticiones).
//   TypeScript‚Üí Traduce y tipa el lenguaje.
//   Nodemon   ‚Üí Mantiene el servidor vivo y actualizado.
//   tsc       ‚Üí Transforma el c√≥digo .ts a .js para producci√≥n.


  ‚öôÔ∏è CONFIGURACION DEL SERVIDOR:
  - Se instala la dev dependency @types/express para que soporte Ts.
  - Usamos ThunderClient o Postman para probar manualmente los endpoints de nuestra API (son simuladores de peticiones HTTP). Mientras no tenemos una UI en React. EL navegador solo tiene naves de tipo GET y POST (si enviamos un formulario-> <form action='/' method='POST'), solo lee informacion y envia. Postman hay que instalarlo y ThunderClient es una extension de VsCode. NOs quedamos con ThunderClient para este proyecto. Simplemente haces una request y se ve directamente la respuesta.-- USAMOS POSTMAN- ThunderClient es de pago ahora.

  - En server.ts instaciamos express. const server= express().
  - Definimos las rutas (routing). Al principio con server.get- server.post, etc pero luego usamos router de express y reemplazamos server por router. Ese router lo importamos en server.ts
  - Separamos las rutas a su propio archivo. router.ts de esa manera resumimos en server.use('/', router) todas las rutas que router.ts tiene. el .use engloba todos los verbos HTTP.

  ‚öôÔ∏è CONFIGURACION DE LA BASE DE DATOS: (PostgreSQL)
  - Usamos Render para alojar la API y DB en la nube. De esta manera sera accesible mas alla de mi local.--> En el panel de render hacemos NEW POSTGRESS y llenamos los datos (name)--> create Db--> nos da un connection string 'URL de conexion' para usar desde .env con OTRA dependencia: doteenv

  - Creamos carpeta config y archivo db.ts.- Ahi establecemos conexion a traves de sequelize con Render

  - Usamos Sequelize (ORM) para traducir los objetos TypeScript a SQL. Ejecutamos los npm de la documentacion. npm install --save sequelize y npm install --save pg pg-hstore # Postgres. Mas adelante en el curso se instala npm i sequelize-typescript para tener soporte de Ts y se reemplaza la instancia de sequelize en db.ts --> import {Sequelize} from 'sequelize-typescript'

  - Usamos Dbeaver para ver las tablas de la DB. En el icono de enchufe para arriba con un + dice PostgreSQL. Ahi llenamos los datos que nos da Render. (en el connection string tambien estan los datos. Host (es lo que esta despues de @ hasta .com- inicia con dpg) Database es lo que esta despues de .com/ Autenticacion dejar DatabaseNative. Password esta despues de : hasta @)- Le damos en probar conexion y va a aparecer un panel con nuestra DB. Ahi expandemos hasta ver los esquemas tablas, etc bieeennnnnn

  - Agregamos Colors para los mensajes en la consola. Ayuda a distinguir la informacion. npm install color--> ve la documentacion. es colors.aparecen los colores... Luego, todos los mensajes por consola los podemos estilizar.

  - Creamos el Modelo de Products. Esto es la tabla de productos. Esta tabla la hacemos con sequelize -ORM- es el traductor entre el codigo y PostgreSQL. Para ello creamos la carpeta models. Un modelo es un 'molde' es como debe ser la tabla. La tabla la crea sequelize traduciendo a SQL el codigo Ts. Para 'ver' la tabla se usa Dbeaver. El modelo esta SINCRONIZADO con las columnas de la DB. Por eso el db.sync() en server.ts

  ‚öôÔ∏è CREANDO FUNCIONES PARA INTERACTUAR CON LA DB

  **POSTMAN: fiajte como hiciste las anteriores, guardas una coleccion por proyecto y vas guardando las request --> new request ***
  
  - Creamos la carpeta handlers --> product.ts : funciones que manejan el modelo Product. Ahi estaran las funciones que van a reemplazar (req, res) en router.ts
  - Para enviar datos al endpoints usamos POSTMAN.- Almacenamos las peticiones http en una nueva coleccion para mejor organizaci√≥n. -> en el panel Collection. Para enviar en postman es en "raw" - Json y escribes en json
  - Te das cuenta que la configuraci√≥n de tsconfig.json es vital para el proyecto, muchos errores que van apareciendo se deben a que hay que ir agregando "soporte".
  - Creamos la carpeta middelware en Src para separar validacion y dejar el handler limpio.7
  - Usamos el routing dinamico de Express para buscar por Id. Creamos el endpoint que va a enviar en la URL el id que buscamos.


‚öôÔ∏è TESTING: JEST Y SUPERTEST
 - Unit Testing: verifica partes individuales del codigo.
 - Integration Testing: verificar que 2 o mas piezas del codigo funcionen.

 * 1. Jest ‚Üí Test Runner
 *    - Ejecuta, organiza y eval√∫a los tests.
 *    - Permite usar funciones como `describe`, `it`, `test` y `expect`.
 *    - Se encarga de mostrar los resultados, manejar mocks, spies y coverage.
      - no sabe nada sobre HTTP o APIs ‚Äî solo ejecuta y eval√∫a tus tests.
 *
 * 2. Supertest ‚Üí Cliente HTTP simulado
 *    - Env√≠a peticiones HTTP simuladas (GET, POST, PUT, DELETE...) a tu API Express.
 *    - No necesita que el servidor est√© escuchando en un puerto real(no usa Render, ni Postman, ni nada externo).
 *    - Permite verificar c√≥digo de estado, cabeceras y contenido de respuesta.
 *
 * Relaci√≥n entre ambos:
 *    - Jest ejecuta los tests.
 *    - Supertest se usa dentro de esos tests para probar los endpoints.

- Instalamos las dependencias: Supertest--> npm i -D supertest @types/supertest jest @types/jest ts-jest

Sin @types/jest, TypeScript marcar√≠a error en funciones como describe, it, o expect.

Sin @types/supertest, no sabr√≠a qu√© tipo devuelve request(app).get('/').

TS-JEST:

ts-jest es un preprocesador que le permite a Jest entender y ejecutar archivos .ts directamente, sin que tengas que compilar antes con tsc.

Funciona as√≠:

Jest ve un archivo .ts

ts-jest lo transforma internamente a JavaScript usando la configuraci√≥n de tu tsconfig.json

Y reci√©n ah√≠ Jest lo ejecuta.

Sin ts-jest, Jest solo puede correr archivos .js.

- Ejecutamos npx ts-jest config:init --> es una forma r√°pida de crear autom√°ticamente el archivo de configuraci√≥n de Jest adaptado a TypeScript.

- Jest tiene 3 formas de encontrar los archivos donde estan las pruebas: archivo .test.js archivo .spec.js o archivos dentro de la carpeta __tests__ (usamos esta ultima forma). Creamos la carpeta __tests__ en src y dentro el archivo server.test.ts. Hacemos lo mismo para los test de handlers asi cada carpeta tiene su tests.

- El test de server.ts es para probar que el servidor esta vivo, que arranca y brinda una respuesta.

- Luego procedemos a los test del handler que verifica la validacion, etc.

- Para limpiar la base de datos, eliminar todo despues de hacer las pruebas testing y evitamos llenar la Db de pruebas aunque eso debe hacerse en una DB de prueba, creamos la carpeta data -> y el archivo index.ts. Ahi usamos la dependencia exit de node y forzamos la eliminacion con {force:true}  y en el packageJson

- Desde Dbeaver eliminaba la base de datos con el codigo sql TRUNCATE TABLE products RESTART IDENTITY; pero hacerlo desde mi codigo en mi proyecto es mucho mas pro!

‚öôÔ∏è CODE COVERAGE: 
- Metrica para la cantidad de codigo ejecutado al menos 1 vez. >=80% es lo aceptable. 
- En el packageJson se agrega un script: "test:coverage": "npm run pretest && jest --detectOpenHandles --coverage"
- Vemos que los try catch no son relevantes porque aseguramos desde el codigo que no entre en el catch. Por eso Jest nos muestra en el coverage que product.ts tiene varias lineas que no se ejecutaron nunca (la mayoria son los catchs). Los eliminamos. Se podria en lugar d eeliminarlos reescribirlos con un    catch (error) {
    console.error(error);
    res.status(500).json({ error: "Error interno del servidor" });
  }
  - Forzamos un error en la conexion con la DB a traves de Jest con funciones como:spyOn y mockRejectedValue. Para ello creamos un archivo en __test__\dbConnection.test.ts  ya que ahi estan las lineas que no se ejecutan segun el reporte de code coverage.


  -‚öôÔ∏è SWAGGER : Documentar Apis: Swagger. Instalamos Swagger --> npm i swagger-jsdoc swagger-ui-express y para tener los types npm i -D @types/swagger-jsdoc @types/swagger-ui-express
  - Se crea archivo swagger.ts en la carpeta config /src/config --> ahi va la informacion general de la API se configura el objeto de options.
  - Se agrega una ruta para la Doc en el server.ts para eso usamos swaggerUi.
  - Creamos el schema de productos. Agregamos en comentarios para que swagger los lea. Asi funciona swagger. Es muy sensible a los espacios.
  - Agregamos custom Css en la configuraci√≥n de swagger, lo exportamos y asi personalizamos el sitio de documentacion.

  * Renombramos la carpeta donde esta todo el servidor como 'server'. Creamos una nueva carpeta que agrupe 'server' + 'client'* cuando queremos correr el cliente PRIMERO hay que instalar las dependencias npm install y despues npm run dev














===***AL FINAL RECUERDA HACER UN RESUMEN DEL tsconfig.JSON CON AI PARA SABER QUE HACE CADA COSA===***